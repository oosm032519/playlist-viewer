/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main/typescript/MessageManager.ts":
/*!***********************************************!*\
  !*** ./src/main/typescript/MessageManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageManager: () => (/* binding */ MessageManager)\n/* harmony export */ });\nclass MessageManager {\n    constructor() {\n        // ログイン結果に対応するメッセージのマップ\n        this.loginMessages = {\n            'success': 'Spotifyログインに成功しました',\n            'failure': 'Spotifyログインに失敗しました'\n        };\n    }\n    // メッセージを表示するメソッド\n    showMessage(message) {\n        const messageDiv = this.createMessageElement(message);\n        this.addMessageToDOM(messageDiv);\n        this.removeElementAfterDelay(messageDiv, 3000);\n    }\n    // メッセージ要素を作成するメソッド\n    createMessageElement(message) {\n        const messageDiv = document.createElement('div');\n        messageDiv.textContent = message;\n        messageDiv.className = 'fixed bottom-5 right-5 p-2.5 bg-green-500 text-white rounded-full';\n        return messageDiv;\n    }\n    // メッセージをDOMに追加するメソッド\n    addMessageToDOM(messageDiv) {\n        document.body.appendChild(messageDiv);\n    }\n    // 一定時間後に要素を削除するメソッド\n    removeElementAfterDelay(element, delay) {\n        setTimeout(() => {\n            document.body.removeChild(element);\n        }, delay);\n    }\n    // ログイン結果メッセージを表示するメソッド\n    displayLoginResultMessage() {\n        // URLパラメータを取得\n        const urlParams = new URLSearchParams(window.location.search);\n        const loginResult = urlParams.get('loginResult');\n        // メッセージを取得\n        const message = this.getLoginMessage(loginResult);\n        // メッセージが存在する場合、それを表示\n        if (message) {\n            this.showMessage(message);\n        }\n    }\n    // ログイン結果に対応するメッセージを取得するメソッド\n    getLoginMessage(loginResult) {\n        return this.loginMessages[loginResult];\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/MessageManager.ts?");

/***/ }),

/***/ "./src/main/typescript/descriptionManager.ts":
/*!***************************************************!*\
  !*** ./src/main/typescript/descriptionManager.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DescriptionManager: () => (/* binding */ DescriptionManager)\n/* harmony export */ });\nclass DescriptionManager {\n    constructor() {\n        this.descriptions = {\n            'Acousticness': 'アコースティック感。1に近いほどアコースティック。',\n            'Danceability': '踊りやすさ。1に近いほど踊りやすい。',\n            'Energy': '曲の激しさ。1に近いほど激しい。',\n            'Liveness': 'ライブ感。1に近いほどライブらしい。',\n            'Speechiness': '曲中の話し言葉の存在度合い。1に近いほど話し言葉が多い。',\n            'Valence': '明るさ。1に近いほど明るい。'\n        };\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/descriptionManager.ts?");

/***/ }),

/***/ "./src/main/typescript/loadingAnimationManager.ts":
/*!********************************************************!*\
  !*** ./src/main/typescript/loadingAnimationManager.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoadingAnimationManager: () => (/* binding */ LoadingAnimationManager)\n/* harmony export */ });\nclass LoadingAnimationManager {\n    // ローディングアニメーションを表示するメソッド\n    showLoadingAnimation() {\n        document.getElementById('loading').classList.remove('hidden');\n    }\n    // ローディングアニメーションを非表示にするメソッド\n    hideLoadingAnimation() {\n        document.getElementById('loading').classList.add('hidden');\n    }\n    toggleLoadingAnimation() {\n        const loadingElement = document.getElementById('loading');\n        loadingElement.classList.toggle('hidden');\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/loadingAnimationManager.ts?");

/***/ }),

/***/ "./src/main/typescript/main.ts":
/*!*************************************!*\
  !*** ./src/main/typescript/main.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _playlistManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./playlistManager */ \"./src/main/typescript/playlistManager.ts\");\n/* harmony import */ var _pageInitializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pageInitializer */ \"./src/main/typescript/pageInitializer.ts\");\n/* harmony import */ var _toggleVisitedPlaylists__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toggleVisitedPlaylists */ \"./src/main/typescript/toggleVisitedPlaylists.ts\");\n/* harmony import */ var _spotifyAuthorizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./spotifyAuthorizer */ \"./src/main/typescript/spotifyAuthorizer.ts\");\n\n\n\n\nclass Main {\n    constructor() {\n        new _pageInitializer__WEBPACK_IMPORTED_MODULE_1__.PageInitializer();\n        this.toggleVisitedPlaylists = new _toggleVisitedPlaylists__WEBPACK_IMPORTED_MODULE_2__.ToggleVisitedPlaylists();\n        this.spotifyAuthorizer = new _spotifyAuthorizer__WEBPACK_IMPORTED_MODULE_3__.SpotifyAuthorizer();\n        this.playlistManager = new _playlistManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistManager();\n        this.addEventListeners();\n    }\n    addEventListeners() {\n        document.getElementById('visited-playlists').addEventListener('click', () => this.toggleVisitedPlaylists.toggle());\n        document.getElementById('spotify-login').addEventListener('click', () => this.spotifyAuthorizer.authorize());\n        document.getElementById('show-playlists').addEventListener('click', () => this.playlistManager.fetchUserPlaylists());\n    }\n}\nnew Main();\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/main.ts?");

/***/ }),

/***/ "./src/main/typescript/pageInitializer.ts":
/*!************************************************!*\
  !*** ./src/main/typescript/pageInitializer.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PageInitializer: () => (/* binding */ PageInitializer)\n/* harmony export */ });\n/* harmony import */ var _uiManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uiManager */ \"./src/main/typescript/uiManager.ts\");\n/* harmony import */ var _playlistManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./playlistManager */ \"./src/main/typescript/playlistManager.ts\");\n/* harmony import */ var _MessageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MessageManager */ \"./src/main/typescript/MessageManager.ts\");\n\n\n\nclass PageInitializer {\n    constructor() {\n        this.uiManager = new _uiManager__WEBPACK_IMPORTED_MODULE_0__.UIManager();\n        this.playlistManager = new _playlistManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistManager();\n        this.messageManager = new _MessageManager__WEBPACK_IMPORTED_MODULE_2__.MessageManager();\n        this.initializePage();\n    }\n    initializePage() {\n        this.setupUIManager();\n        this.fetchVisitedPlaylists();\n    }\n    setupUIManager() {\n        this.uiManager.togglePlaylistSearchOption();\n        this.uiManager.toggleSideMenu();\n        this.messageManager.displayLoginResultMessage();\n        this.uiManager.addSubmitEventToForm('playlistForm', this.playlistManager.handlePlaylistFormSubmit.bind(this.playlistManager));\n        this.uiManager.addSubmitEventToForm('searchForm', this.playlistManager.handleSearchFormSubmit.bind(this.playlistManager));\n    }\n    fetchVisitedPlaylists() {\n        this.playlistManager.fetchVisitedPlaylists();\n    }\n}\n// ページ読み込み完了時の処理\ndocument.addEventListener('DOMContentLoaded', () => {\n    new PageInitializer();\n});\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/pageInitializer.ts?");

/***/ }),

/***/ "./src/main/typescript/playlistIdManager.ts":
/*!**************************************************!*\
  !*** ./src/main/typescript/playlistIdManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlaylistIdManager: () => (/* binding */ PlaylistIdManager)\n/* harmony export */ });\nclass PlaylistIdManager {\n    constructor() {\n        this.playlistTrackIds = [];\n    }\n    static getInstance() {\n        if (!PlaylistIdManager.instance) {\n            PlaylistIdManager.instance = new PlaylistIdManager();\n        }\n        return PlaylistIdManager.instance;\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/playlistIdManager.ts?");

/***/ }),

/***/ "./src/main/typescript/playlistManager.ts":
/*!************************************************!*\
  !*** ./src/main/typescript/playlistManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlaylistManager: () => (/* binding */ PlaylistManager)\n/* harmony export */ });\n/* harmony import */ var _uiManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uiManager */ \"./src/main/typescript/uiManager.ts\");\n/* harmony import */ var _playlistIdManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./playlistIdManager */ \"./src/main/typescript/playlistIdManager.ts\");\n/* harmony import */ var _trackTable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trackTable */ \"./src/main/typescript/trackTable.ts\");\n/* harmony import */ var _trackManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./trackManager */ \"./src/main/typescript/trackManager.ts\");\n/* harmony import */ var _MessageManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MessageManager */ \"./src/main/typescript/MessageManager.ts\");\n/* harmony import */ var _loadingAnimationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loadingAnimationManager */ \"./src/main/typescript/loadingAnimationManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nclass PlaylistManager {\n    constructor() {\n        this.uiManager = new _uiManager__WEBPACK_IMPORTED_MODULE_0__.UIManager();\n        this.playlistIdManager = _playlistIdManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistIdManager.getInstance();\n        this.trackManager = new _trackManager__WEBPACK_IMPORTED_MODULE_3__.TrackManager();\n        this.messageManager = new _MessageManager__WEBPACK_IMPORTED_MODULE_4__.MessageManager();\n        this.loadingAnimationManager = new _loadingAnimationManager__WEBPACK_IMPORTED_MODULE_5__.LoadingAnimationManager();\n        // ユーザーのプレイリストを取得する\n        this.fetchUserPlaylists = () => this.fetchDataAndUpdateUI(() => this.fetchPlaylistsFromAPI(), (data) => this.uiManager.displayPlaylists(data));\n        // プレイリストの詳細を取得し表示する\n        this.fetchAndDisplayPlaylistDetails = (playlist) => this.fetchDataAndUpdateUI(() => {\n            this.playlistIdManager.playlistId = playlist.id;\n            return this.fetchPlaylistDuplicate(playlist.id);\n        }, (data) => this.uiManager.displayPlaylistDetails(playlist, data));\n        // プレイリストフォームの送信イベントハンドラ\n        this.handlePlaylistFormSubmit = this.createFormSubmitHandler('playlistId', this.fetchPlaylistData.bind(this));\n        // 検索フォームの送信イベントハンドラ\n        this.handleSearchFormSubmit = this.createFormSubmitHandler('searchQuery', this.fetchSearchData.bind(this));\n        this.uiManager = new _uiManager__WEBPACK_IMPORTED_MODULE_0__.UIManager();\n    }\n    // データ取得とUI更新の共通処理\n    fetchDataAndUpdateUI(fetchData, updateUI) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.loadingAnimationManager.showLoadingAnimation();\n                const data = yield fetchData();\n                updateUI(data);\n            }\n            catch (error) {\n                this.messageManager.showMessage(error.message);\n            }\n            finally {\n                this.loadingAnimationManager.hideLoadingAnimation();\n            }\n        });\n    }\n    // APIからプレイリストを取得する非同期関数\n    fetchPlaylistsFromAPI() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch('/java/spotify/user/playlists');\n            if (!response.ok) {\n                const message = yield response.text();\n                throw new Error(message);\n            }\n            return response.json();\n        });\n    }\n    // プレイリストの詳細を取得する\n    fetchPlaylistDuplicate(playlistId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.playlistIdManager.playlistId = playlistId;\n            const response = yield fetch(`/java/playlist/${playlistId}`);\n            if (!response.ok) {\n                throw new Error('There was a problem with the fetch operation');\n            }\n            return yield response.json();\n        });\n    }\n    // ユーザーが訪れたプレイリストを取得する非同期関数\n    fetchVisitedPlaylists() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield this.fetchDataFromEndpoint('/java/user/visited-playlists');\n                this.createAndDisplayTable(data);\n            }\n            catch (error) {\n                console.error('There was a problem with the fetch operation: ', error);\n            }\n        });\n    }\n    fetchDataFromEndpoint(endpoint) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(endpoint, { credentials: 'include' });\n            this.checkResponseStatus(response);\n            return yield response.json();\n        });\n    }\n    createAndDisplayTable(data) {\n        const visitedPlaylistsDiv = document.getElementById('visitedPlaylists');\n        this.uiManager.createUITable(visitedPlaylistsDiv, data);\n    }\n    // レスポンスのステータスをチェックする関数\n    checkResponseStatus(response) {\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n    }\n    // APIからデータを取得する\n    fetchDataFromAPI(url, handler) {\n        this.resetPlaylistTrackIds();\n        this.prepareUIForDataFetching();\n        fetch(url)\n            .then(_trackTable__WEBPACK_IMPORTED_MODULE_2__.TrackTable.handleResponse)\n            .then(handler.bind(this))\n            .catch(_trackTable__WEBPACK_IMPORTED_MODULE_2__.TrackTable.handleError)\n            .finally(() => {\n            this.loadingAnimationManager.hideLoadingAnimation();\n        });\n    }\n    // プレイリストのトラックIDをリセットする\n    resetPlaylistTrackIds() {\n        this.playlistIdManager.playlistTrackIds = [];\n    }\n    // データ取得のためのUIを準備する\n    prepareUIForDataFetching() {\n        this.uiManager.clearAllTables();\n        this.loadingAnimationManager.showLoadingAnimation();\n    }\n    // プレイリストデータを取得する\n    fetchPlaylistData(playlistId) {\n        this.playlistIdManager.playlistId = playlistId;\n        this.fetchDataFromAPI(`/java/playlist/${playlistId}`, this.handlePlaylistData);\n    }\n    // 検索データを取得する\n    fetchSearchData(searchQuery) {\n        this.fetchDataFromAPI(`/java/search/${searchQuery}`, (data) => {\n            console.log(\"Search results:\", data); // 検索結果をコンソールに表示\n            this.handleSearchData(data);\n        });\n    }\n    // プレイリストの詳細を取得・表示する\n    fetchPlaylistDetails(result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `/java/playlist/${result.id}`;\n            this.playlistIdManager.playlistId = result.id;\n            const data = yield this.fetchData(url);\n            this.uiManager.validateData(data);\n            return data;\n        });\n    }\n    fetchData(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch data from ${url}`);\n            }\n            return yield response.json();\n        });\n    }\n    fetchAndDisplayPlaylistDetailsUI(result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadingAnimationManager.toggleLoadingAnimation();\n            this.playlistIdManager.playlistId = result.id;\n            try {\n                yield this.handlePlaylistDetails(result);\n            }\n            catch (error) {\n                console.error(error.message);\n                this.messageManager.showMessage(`Error: ${error.message}`);\n            }\n            finally {\n                this.loadingAnimationManager.toggleLoadingAnimation();\n            }\n        });\n    }\n    handlePlaylistDetails(result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.fetchPlaylistDetails(result);\n            this.uiManager.displayPlaylistDetails(result, data);\n        });\n    }\n    // フォーム送信イベントハンドラを作成するメソッド\n    createFormSubmitHandler(inputId, fetchData) {\n        return (event) => {\n            event.preventDefault();\n            const inputElement = this.uiManager.getElementById(inputId);\n            const inputValue = inputElement.value.trim(); // 空白を削除\n            if (inputValue) { // 入力が空でないことを確認\n                fetchData(inputValue);\n            }\n            else {\n                this.messageManager.showMessage('検索クエリを入力してください');\n            }\n        };\n    }\n    // プレイリストデータの処理\n    handlePlaylistData(data) {\n        this.uiManager.clearAllTables();\n        this.processPlaylistData(data);\n        this.loadingAnimationManager.hideLoadingAnimation();\n    }\n    // 検索データの処理\n    handleSearchData(data) {\n        this.uiManager.clearAllTables();\n        if (data && Array.isArray(data)) { // データが配列であることを確認\n            this.uiManager.createSearchResultsTable(data);\n        }\n        else {\n            console.error('Expected data to be an array but received', data);\n            this.messageManager.showMessage('検索結果が見つかりませんでした');\n        }\n        this.loadingAnimationManager.hideLoadingAnimation();\n    }\n    // プレイリストデータの処理\n    processPlaylistData(data) {\n        if (this.uiManager.isValidData(data)) {\n            const tracks = this.trackManager.createTracks(data);\n            this.uiManager.createDomTable(tracks);\n            this.trackManager.calculateAverageAndMode(tracks);\n            this.uiManager.displayPlaylistName(data.name);\n        }\n        else {\n            console.error('Expected data.tracks to be an array but received', data);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/playlistManager.ts?");

/***/ }),

/***/ "./src/main/typescript/spotifyAuthorizer.ts":
/*!**************************************************!*\
  !*** ./src/main/typescript/spotifyAuthorizer.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpotifyAuthorizer: () => (/* binding */ SpotifyAuthorizer)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass SpotifyAuthorizer {\n    authorize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield fetch('/java/authorize');\n                const uri = yield response.text();\n                console.log(\"認証が完了しました\");\n                console.log(uri);\n                window.location.href = uri;\n            }\n            catch (error) {\n                console.error('There was a problem with the fetch operation: ', error);\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/spotifyAuthorizer.ts?");

/***/ }),

/***/ "./src/main/typescript/toggleVisitedPlaylists.ts":
/*!*******************************************************!*\
  !*** ./src/main/typescript/toggleVisitedPlaylists.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToggleVisitedPlaylists: () => (/* binding */ ToggleVisitedPlaylists)\n/* harmony export */ });\nclass ToggleVisitedPlaylists {\n    constructor() {\n        this.isVisitedPlaylistsVisible = false;\n    }\n    toggle() {\n        const visitedPlaylistsDiv = document.getElementById('visitedPlaylists');\n        visitedPlaylistsDiv.classList.toggle('hidden');\n        const button = document.getElementById('visited-playlists');\n        this.isVisitedPlaylistsVisible = !this.isVisitedPlaylistsVisible;\n        button.textContent = this.isVisitedPlaylistsVisible ? '参照履歴を非表示' : '参照履歴を表示';\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/toggleVisitedPlaylists.ts?");

/***/ }),

/***/ "./src/main/typescript/track.ts":
/*!**************************************!*\
  !*** ./src/main/typescript/track.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Track: () => (/* binding */ Track)\n/* harmony export */ });\nclass Track {\n    constructor(track, audioFeatures) {\n        this.id = track.id;\n        this.name = track.name;\n        this.artists = track.artists;\n        this.audioFeatures = audioFeatures;\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/track.ts?");

/***/ }),

/***/ "./src/main/typescript/trackManager.ts":
/*!*********************************************!*\
  !*** ./src/main/typescript/trackManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackManager: () => (/* binding */ TrackManager)\n/* harmony export */ });\n/* harmony import */ var _track__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track */ \"./src/main/typescript/track.ts\");\n/* harmony import */ var _uiManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uiManager */ \"./src/main/typescript/uiManager.ts\");\n/* harmony import */ var _playlistIdManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./playlistIdManager */ \"./src/main/typescript/playlistIdManager.ts\");\n/* harmony import */ var _MessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MessageManager */ \"./src/main/typescript/MessageManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass TrackManager {\n    constructor() {\n        this.uiManager = new _uiManager__WEBPACK_IMPORTED_MODULE_1__.UIManager();\n        this.playlistIdManager = _playlistIdManager__WEBPACK_IMPORTED_MODULE_2__.PlaylistIdManager.getInstance();\n        this.messageManager = new _MessageManager__WEBPACK_IMPORTED_MODULE_3__.MessageManager();\n    }\n    calculateAverageAndMode(tracks) {\n        const sum = this.calculateSum(tracks);\n        const average = this.calculateAverage(sum, tracks.length);\n        const mode = this.calculateMode(sum);\n        this.fetchRecommendedTracks(average, mode);\n    }\n    fetchRecommendedTracks(average, mode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const artistNamesParam = mode.topFiveArtistNames.join(',');\n            const data = yield this.fetchRecommendationsFromAPI(average, mode, artistNamesParam);\n            this.uiManager.processRecommendationData(data);\n        });\n    }\n    fetchRecommendationsFromAPI(average, mode, artistNamesParam) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.constructAPIUrl(average, mode, artistNamesParam);\n            const response = yield fetch(url);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch recommendations. Status: ${response.status} ${response.statusText}`);\n            }\n            return yield response.json();\n        });\n    }\n    constructAPIUrl(average, mode, artistNamesParam) {\n        return `/java/recommendations?tempo=${average.averageTempo}&key=${mode.modeKey}&danceability=${average.averageDanceability}&energy=${average.averageEnergy}&acousticness=${average.averageAcousticness}&liveness=${average.averageLiveness}&speechiness=${average.averageSpeechiness}&valence=${average.averageValence}&modeArtistNames=${artistNamesParam}`;\n    }\n    // レスポンスデータをログに出力する関数\n    logResponseData(data) {\n        console.log(\"Response data:\", data);\n    }\n    // レコメンドトラックをログに出力する関数\n    logRecommendedTracks(tracks) {\n        console.log(\"Recommended tracks based on the playlist:\");\n        tracks.forEach((track) => {\n            console.log(`- ${track.name} by ${track.artists[0].name}`);\n        });\n        console.log(this.playlistIdManager.playlistTrackIds);\n    }\n    // トラックをペアにする関数\n    createTrackPairs(tracks) {\n        const trackPairs = [];\n        for (let i = 0; i < tracks.length; i += 2) {\n            trackPairs.push(tracks.slice(i, i + 2));\n        }\n        return trackPairs;\n    }\n    // ペアの行を作成する関数\n    createRowForPair(pair, playlistId) {\n        const row = document.createElement('tr');\n        pair.forEach((track) => {\n            this.appendTrackToRow(row, track, playlistId);\n        });\n        return row;\n    }\n    // トラックを行に追加する関数\n    appendTrackToRow(row, track, playlistId) {\n        const cell = this.createCellForTrack(track);\n        const addButton = this.createAddButton(track, playlistId, cell);\n        const removeButton = this.createRemoveButton(track, playlistId, cell, row);\n        row.appendChild(cell);\n        row.appendChild(addButton);\n        row.appendChild(removeButton);\n    }\n    // トラックのセルを作成する関数\n    createCellForTrack(track) {\n        const cell = document.createElement('td');\n        cell.textContent = `${track.name} by ${track.artists[0].name}`;\n        cell.addEventListener('click', () => {\n            window.open(`https://open.spotify.com/track/${track.id}`, '_blank');\n        });\n        return cell;\n    }\n    // 追加ボタンを作成する関数\n    createAddButton(track, playlistId, cell) {\n        return this.createTrackButton(track, playlistId, cell, null, true);\n    }\n    // 削除ボタンを作成する関数\n    createRemoveButton(track, playlistId, cell, row) {\n        return this.createTrackButton(track, playlistId, cell, row, false);\n    }\n    // ボタンを作成する関数\n    createButton(isAddButton) {\n        const button = document.createElement('button');\n        button.textContent = isAddButton ? '+' : '-';\n        button.className = 'track-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded text-center text-lg w-10 h-10 flex items-center justify-center';\n        return button;\n    }\n    // メッセージを生成するメソッド\n    getMessages(isAddButton) {\n        const successMessage = isAddButton ? '楽曲を追加しました！' : '楽曲を削除しました！';\n        const errorMessage = isAddButton ? '楽曲を追加できませんでした' : '楽曲を削除できませんでした';\n        return { successMessage, errorMessage };\n    }\n    // エンドポイントを生成するメソッド\n    getEndpoint(isAddButton) {\n        return isAddButton ? 'addTrack' : 'removeTrack';\n    }\n    // イベントリスナーのコールバック関数\n    handleButtonClick({ track, playlistId, cell, row, isAddButton }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!playlistId) {\n                console.error('Playlist ID is not set.');\n                return;\n            }\n            const endpoint = this.getEndpoint(isAddButton);\n            const { successMessage, errorMessage } = this.getMessages(isAddButton);\n            try {\n                yield this.fetchTrack(`/java/playlist/${endpoint}?trackId=${track.id}&playlistId=${playlistId}`);\n                this.messageManager.showMessage(successMessage);\n                if (isAddButton) {\n                    cell.classList.add('bg-green-100');\n                }\n                else {\n                    if (row.sectionRowIndex % 2 === 0) {\n                        cell.classList.add('bg-white');\n                    }\n                    else {\n                        cell.classList.add('bg-gray-100');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('There was a problem with the fetch operation: ', error);\n                this.messageManager.showMessage(errorMessage);\n            }\n        });\n    }\n    // トラックボタンを作成する関数\n    createTrackButton(track, playlistId, cell, row, isAddButton) {\n        const button = this.createButton(isAddButton);\n        button.classList.add('bg-green-500', 'text-white', 'w-12', 'h-12', 'm-2', 'rounded', 'px-5', 'py-2.5', 'cursor-pointer', 'transition-colors', 'duration-300', 'ease-in-out');\n        button.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            return this.handleButtonClick({\n                track: track,\n                playlistId: playlistId,\n                cell: cell,\n                row: row,\n                isAddButton: isAddButton\n            });\n        }));\n        return button;\n    }\n    fetchTrack(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url);\n            if (!response.ok) {\n                throw new Error('There was a problem with the fetch operation');\n            }\n        });\n    }\n    // ヘッダー行を作成する関数\n    createHeaderRow() {\n        const headerRow = document.createElement('tr');\n        const headerCell = document.createElement('th');\n        headerCell.textContent = \"Recommended Tracks\";\n        headerCell.classList.add('text-white', 'bg-green-500', 'text-center', 'py-2', 'hover:bg-green-600', 'transition-colors', 'duration-300', 'ease-in-out');\n        headerRow.appendChild(headerCell);\n        return headerRow;\n    }\n    // トラックペアの行を作成する関数\n    createRowsForTrackPairs(trackPairs, playlistId) {\n        return trackPairs.map(pair => this.createRowForPair(pair, playlistId));\n    }\n    // テーブルをDOMに追加する関数\n    appendTableToDOM(table) {\n        this.uiManager.playlistTracksDiv.appendChild(table);\n    }\n    // トラックの合計値を計算する関数\n    calculateSum(tracks) {\n        let totalTempo = 0;\n        let totalAcousticness = 0;\n        let totalDanceability = 0;\n        let totalEnergy = 0;\n        let totalLiveness = 0;\n        let totalSpeechiness = 0;\n        let totalValence = 0;\n        let artistNames = [];\n        let keys = [];\n        let modes = [];\n        let playlistTrackIds = [];\n        tracks.forEach(track => {\n            totalTempo += track.audioFeatures.tempo;\n            totalAcousticness += track.audioFeatures.acousticness;\n            totalDanceability += track.audioFeatures.danceability;\n            totalEnergy += track.audioFeatures.energy;\n            totalLiveness += track.audioFeatures.liveness;\n            totalSpeechiness += track.audioFeatures.speechiness;\n            totalValence += track.audioFeatures.valence;\n            artistNames.push(track.artists[0].name);\n            keys.push(track.audioFeatures.key);\n            modes.push(track.audioFeatures.mode);\n            playlistTrackIds.push(track.id);\n        });\n        return {\n            totalTempo,\n            totalAcousticness,\n            totalDanceability,\n            totalEnergy,\n            totalLiveness,\n            totalSpeechiness,\n            totalValence,\n            artistNames,\n            keys,\n            modes,\n            playlistTrackIds\n        };\n    }\n    // 平均値を計算する関数\n    calculateAverage(sum, length) {\n        return {\n            averageTempo: sum.totalTempo / length,\n            averageAcousticness: sum.totalAcousticness / length,\n            averageDanceability: sum.totalDanceability / length,\n            averageEnergy: sum.totalEnergy / length,\n            averageLiveness: sum.totalLiveness / length,\n            averageSpeechiness: sum.totalSpeechiness / length,\n            averageValence: sum.totalValence / length,\n        };\n    }\n    // 最頻値を計算する関数\n    calculateMode(sum) {\n        return {\n            modeKey: this.mode(sum.keys),\n            modeMode: this.mode(sum.modes),\n            topFiveArtistNames: this.getTopFiveMostFrequentValues(sum.artistNames)\n        };\n    }\n    // 配列の最頻値を取得する関数\n    mode(array) {\n        return array.sort((a, b) => array.filter(v => v === a).length\n            - array.filter(v => v === b).length).pop();\n    }\n    // 頻度マップを作成する関数\n    createFrequencyMap(array) {\n        const frequency = {};\n        for (const item of array) {\n            frequency[item] = (frequency[item] || 0) + 1;\n        }\n        return frequency;\n    }\n    // 最頻値を取得する関数\n    getMostFrequentValues(frequency, count) {\n        const sortedKeys = [...Object.keys(frequency)].sort((a, b) => frequency[b] - frequency[a]);\n        return sortedKeys.filter(key => frequency[key] > 1).slice(0, count);\n    }\n    // 配列からランダムな値を取得する関数\n    getRandomValues(array, count) {\n        let values = [];\n        while (values.length < count && array.length > 0) {\n            const randomIndex = Math.floor(Math.random() * array.length);\n            const randomValue = array[randomIndex];\n            if (!values.includes(randomValue)) {\n                values = [...values, randomValue];\n                array.splice(randomIndex, 1);\n            }\n        }\n        return values;\n    }\n    // 最頻値のトップ5を取得する関数\n    getTopFiveMostFrequentValues(array) {\n        const frequency = this.createFrequencyMap(array);\n        const modesCount = 5;\n        let modes = this.getMostFrequentValues(frequency, modesCount);\n        const remainingArtists = Object.keys(frequency).filter(key => frequency[key] === 1);\n        const additionalModesCount = modesCount - modes.length;\n        const additionalModes = this.getRandomValues(remainingArtists, additionalModesCount);\n        return [...modes, ...additionalModes];\n    }\n    calculateTrackAverageAndMode(tracks) {\n        this.calculateAverageAndMode(tracks);\n    }\n    // トラックを作成する\n    createTracks(data) {\n        return data.tracks.map((item) => {\n            this.playlistIdManager.playlistTrackIds.push(item.playlistTrack.track.id);\n            return new _track__WEBPACK_IMPORTED_MODULE_0__.Track(item.playlistTrack.track, item.audioFeatures);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/trackManager.ts?");

/***/ }),

/***/ "./src/main/typescript/trackTable.ts":
/*!*******************************************!*\
  !*** ./src/main/typescript/trackTable.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackTable: () => (/* binding */ TrackTable)\n/* harmony export */ });\n/* harmony import */ var _descriptionManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./descriptionManager */ \"./src/main/typescript/descriptionManager.ts\");\n\nclass TrackTable {\n    constructor(tracks) {\n        this.tracks = tracks;\n    }\n    static handleResponse(response) {\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n    }\n    static handleError(error) {\n        console.error('There was a problem with the fetch operation: ', error);\n    }\n    createTableHeader() {\n        const thead = document.createElement('thead');\n        thead.classList.add('bg-green-500', 'text-white', 'hover:bg-green-600', 'transition-colors', 'duration-300', 'ease-in-out');\n        const headerRow = document.createElement('tr');\n        ['Track Name', 'Artist Name', 'BPM', 'Key', 'Mode', 'Acousticness', 'Danceability', 'Energy', /* 'Instrumentalness', */ 'Liveness', 'Speechiness', 'Valence'].forEach((text, index) => {\n            const th = this.createHeaderCell(text, index);\n            th.classList.add('px-4', 'py-2');\n            headerRow.appendChild(th);\n        });\n        thead.appendChild(headerRow);\n        return thead;\n    }\n    createHeaderCell(text, index) {\n        const th = document.createElement('th');\n        th.textContent = text;\n        const descriptions = new _descriptionManager__WEBPACK_IMPORTED_MODULE_0__.DescriptionManager();\n        if (descriptions.descriptions[text]) {\n            th.title = descriptions.descriptions[text];\n        }\n        th.addEventListener('click', (event) => this.handleHeaderCellClick(event, index));\n        return th;\n    }\n    handleHeaderCellClick(event, index) {\n        const element = event.target;\n        this.toggleSortOrder(element);\n        this.resetSortOrderForOtherColumns(element);\n        this.sortRows(element, index);\n    }\n    toggleSortOrder(element) {\n        if (element.classList.contains('asc')) {\n            element.classList.replace('asc', 'desc');\n        }\n        else if (element.classList.contains('desc')) {\n            element.classList.replace('desc', 'asc');\n        }\n        else {\n            element.classList.add('asc');\n        }\n    }\n    resetSortOrderForOtherColumns(element) {\n        Array.from(element.parentNode.children)\n            .filter(e => e !== element)\n            .forEach(e => e.classList.remove('asc', 'desc'));\n    }\n    sortRows(element, index) {\n        const table = element.closest('table');\n        const tbody = table.querySelector('tbody');\n        const sortOrder = element.classList.contains('asc') ? -1 : 1;\n        const rows = Array.from(tbody.rows);\n        rows.sort((a, b) => TrackTable.sortRows(a, b, index, sortOrder));\n        rows.forEach(row => tbody.appendChild(row));\n    }\n    static sortRows(a, b, columnIndex, sortOrder) {\n        const cellA = TrackTable.getSortValue(a.cells[columnIndex].textContent, columnIndex);\n        const cellB = TrackTable.getSortValue(b.cells[columnIndex].textContent, columnIndex);\n        return (cellA > cellB ? 1 : -1) * sortOrder;\n    }\n    createTableBody() {\n        const tbody = document.createElement('tbody');\n        this.tracks.forEach(track => {\n            const row = this.createRow(track);\n            tbody.appendChild(row);\n        });\n        return tbody;\n    }\n    createRow(track) {\n        const row = document.createElement('tr');\n        row.classList.add('hover:bg-gray-300', 'h-20', 'odd:bg-white', 'even:bg-gray-100', 'transition-colors', 'duration-300', 'ease-in-out');\n        [track.name, track.artists[0].name, track.audioFeatures.tempo, this.keyToNote(track.audioFeatures.key), track.audioFeatures.mode, track.audioFeatures.acousticness, track.audioFeatures.danceability, track.audioFeatures.energy, /* track.audioFeatures.instrumentalness, */ track.audioFeatures.liveness, track.audioFeatures.speechiness, track.audioFeatures.valence].forEach(text => {\n            const td = document.createElement('td');\n            td.textContent = text.toString();\n            td.classList.add('border', 'border-gray-200', 'px-4', 'py-2'); // Tailwind CSS classes to add border and padding\n            row.appendChild(td);\n        });\n        return row;\n    }\n    keyToNote(key) {\n        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n        return NOTES[key];\n    }\n    static getSortValue(cell, columnIndex) {\n        const COLUMN_INDEX_NAME_ARTIST = 0;\n        const COLUMN_INDEX_OTHERS = 1;\n        const COLUMN_INDEX_KEY = 3;\n        const COLUMN_INDEX_MODE = 4;\n        if (columnIndex === COLUMN_INDEX_NAME_ARTIST || columnIndex === COLUMN_INDEX_OTHERS || columnIndex === COLUMN_INDEX_KEY || columnIndex === COLUMN_INDEX_MODE) {\n            return cell;\n        }\n        else {\n            return parseFloat(cell);\n        }\n    }\n    createTable() {\n        const table = document.createElement('table');\n        table.classList.add('playlist-table', 'divide-y', 'divide-gray-200', 'divide-x', 'w-full', 'mx-auto', 'mt-6', 'text-center', 'shadow-md', 'rounded-lg', 'overflow-hidden');\n        table.appendChild(this.createTableHeader());\n        table.appendChild(this.createTableBody());\n        return table;\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/trackTable.ts?");

/***/ }),

/***/ "./src/main/typescript/uiManager.ts":
/*!******************************************!*\
  !*** ./src/main/typescript/uiManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIManager: () => (/* binding */ UIManager)\n/* harmony export */ });\n/* harmony import */ var _playlistManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./playlistManager */ \"./src/main/typescript/playlistManager.ts\");\n/* harmony import */ var _playlistIdManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./playlistIdManager */ \"./src/main/typescript/playlistIdManager.ts\");\n/* harmony import */ var _track__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./track */ \"./src/main/typescript/track.ts\");\n/* harmony import */ var _trackManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./trackManager */ \"./src/main/typescript/trackManager.ts\");\n/* harmony import */ var _trackTable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./trackTable */ \"./src/main/typescript/trackTable.ts\");\n\n\n\n\n\nclass UIManager {\n    // 参照履歴テーブルを作成するメソッド\n    createUITable(visitedPlaylistsDiv, data) {\n        // 既存のテーブルを取得または作成\n        let table = this.getTable(visitedPlaylistsDiv);\n        // 既存のテーブルがある場合は削除\n        if (table) {\n            visitedPlaylistsDiv.removeChild(table);\n        }\n        // 新しいテーブルを作成\n        table = document.createElement('table');\n        table.classList.add('divide-y', 'divide-gray-200', 'w-full', 'mx-auto', 'mt-6', 'text-center', 'shadow-md', 'rounded-lg', 'overflow-hidden');\n        visitedPlaylistsDiv.appendChild(table);\n        // テーブルヘッダーを作成して追加\n        const thead = this.createTableHeader();\n        thead.classList.add('bg-green-500', 'text-white', 'hover:bg-green-600', 'transition-colors', 'duration-300', 'ease-in-out');\n        table.appendChild(thead);\n        // テーブルボディを作成して追加\n        const tbody = this.createTableBody(table, data);\n        tbody.classList.add('divide-y', 'divide-gray-200');\n        table.appendChild(tbody);\n        // visitedPlaylistsDivを非表示に設定\n        visitedPlaylistsDiv.classList.add('hidden');\n    }\n    // visitedPlaylistsDivからテーブルを取得する関数\n    getTable(visitedPlaylistsDiv) {\n        let table = visitedPlaylistsDiv.querySelector('table');\n        if (!table) {\n            table = document.createElement('table');\n            visitedPlaylistsDiv.appendChild(table);\n        }\n        return table;\n    }\n    // フォームの表示を切り替えるメソッド\n    toggleFormVisibility(showForm, hideForm) {\n        showForm.classList.remove('hidden');\n        hideForm.classList.add('hidden');\n    }\n    // オプションの変更イベントを監視するメソッド\n    addChangeEventToOption(option, showForm, hideForm) {\n        option.addEventListener('change', () => {\n            if (option.checked) {\n                this.toggleFormVisibility(showForm, hideForm);\n            }\n        });\n    }\n    // プレイリスト検索オプションを切り替えるメソッド\n    togglePlaylistSearchOption() {\n        this.toggleOption('playlistIdOption', 'playlistForm', 'searchForm');\n        this.toggleOption('searchQueryOption', 'searchForm', 'playlistForm');\n    }\n    // オプションの切り替えを行うメソッド\n    toggleOption(optionId, showFormId, hideFormId) {\n        const option = document.getElementById(optionId);\n        const showForm = document.getElementById(showFormId);\n        const hideForm = document.getElementById(hideFormId);\n        const labelForOption = document.querySelector(`label[for=\"${optionId}\"]`);\n        this.addChangeEventToOption(option, showForm, hideForm);\n        // すべてのラジオボタンを取得\n        const allOptions = document.querySelectorAll(`input[name=\"${option.name}\"]`);\n        allOptions.forEach((otherOption) => {\n            otherOption.addEventListener('change', () => {\n                if (otherOption !== option) {\n                    // 他のラジオボタンが選択されたとき、このラジオボタンのスタイルをデフォルトに戻す\n                    labelForOption.classList.remove('bg-green-500', 'text-white');\n                    labelForOption.classList.add('bg-white', 'text-green-500');\n                }\n            });\n        });\n        option.addEventListener('change', () => {\n            if (option.checked) {\n                // ラジオボタンが選択されたとき、スタイルを変更\n                labelForOption.classList.remove('bg-white', 'text-green-500');\n                labelForOption.classList.add('bg-green-500', 'text-white');\n            }\n        });\n    }\n    // サイドメニューを切り替えるメソッド\n    toggleSideMenu() {\n        // ボタンを取得\n        const openButton = document.getElementById('open');\n        const closeButton = document.getElementById('close');\n        // オープンボタンのクリックイベントを追加\n        openButton.addEventListener('click', this.toggleMenuClass);\n        // クローズボタンのクリックイベントを追加\n        closeButton.addEventListener('click', this.toggleMenuClass);\n    }\n    // サイドメニューのクラスを切り替えるメソッド\n    toggleMenuClass() {\n        const sideMenu = document.getElementById('side-menu');\n        sideMenu.classList.toggle('translate-x-full');\n    }\n    // テーブルの幅をチェックする関数\n    checkTableWidth() {\n        // 全てのテーブルを取得\n        const tables = document.querySelectorAll('table');\n        tables.forEach((table) => {\n            // テーブルの幅がウィンドウの幅より大きい場合\n            if (table.offsetWidth > window.innerWidth) {\n                // スクロールバーを表示\n                table.style.overflowX = 'scroll';\n            }\n            else {\n                // スクロールバーを非表示\n                table.style.overflowX = 'auto';\n            }\n        });\n    }\n    // テーブルヘッダーを作成する関数\n    createTableHeader() {\n        const thead = document.createElement('thead');\n        const headerRow = document.createElement('tr');\n        const headerCell = document.createElement('th');\n        headerCell.textContent = \"参照履歴\";\n        headerRow.appendChild(headerCell);\n        thead.appendChild(headerRow);\n        return thead;\n    }\n    // テーブルボディを作成する関数\n    createTableBody(table, data) {\n        let tableBody = table.querySelector('tbody');\n        if (!tableBody) {\n            tableBody = document.createElement('tbody');\n            table.appendChild(tableBody);\n        }\n        data.forEach((playlist) => {\n            const row = this.createTableRow(playlist);\n            row.classList.add('border', 'border-gray-300', 'odd:bg-white', 'even:bg-gray-100', 'hover:bg-gray-200', 'transition-colors', 'duration-300', 'ease-in-out');\n            tableBody.appendChild(row);\n        });\n        return tableBody;\n    }\n    // テーブル行を作成する関数\n    createTableRow(playlist) {\n        const row = document.createElement('tr');\n        const nameCell = document.createElement('td');\n        nameCell.textContent = playlist.name;\n        row.appendChild(nameCell);\n        const playlistManager = new _playlistManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistManager();\n        row.addEventListener('click', () => playlistManager.fetchAndDisplayPlaylistDetails(playlist));\n        return row;\n    }\n    // レコメンド曲のデータを処理する関数\n    processRecommendationData(data) {\n        const trackManager = new _trackManager__WEBPACK_IMPORTED_MODULE_3__.TrackManager();\n        trackManager.logResponseData(data);\n        const playlistIdManager = _playlistIdManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistIdManager.getInstance();\n        if (data.tracks) {\n            const filteredTracks = data.tracks.filter((track) => !playlistIdManager.playlistTrackIds.includes(track.id));\n            trackManager.logRecommendedTracks(filteredTracks);\n            this.displayRecommendedTracks(filteredTracks);\n        }\n        else {\n            console.log(\"No tracks found in the response.\");\n        }\n    }\n    // 推奨曲を表示する関数\n    displayRecommendedTracks(tracks) {\n        const table = document.createElement('table');\n        // Tailwind CSS classes for styling the table\n        table.classList.add('recommendations-table', 'divide-x', 'divide-y', 'divide-gray-200', 'w-full', 'mx-auto', 'mt-6', 'text-center', 'shadow-md', 'rounded-lg', 'overflow-hidden');\n        const trackManager = new _trackManager__WEBPACK_IMPORTED_MODULE_3__.TrackManager();\n        table.appendChild(trackManager.createHeaderRow());\n        const playlistIdManager = _playlistIdManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistIdManager.getInstance();\n        const trackPairs = trackManager.createTrackPairs(tracks);\n        const rows = trackManager.createRowsForTrackPairs(trackPairs, playlistIdManager.playlistId);\n        rows.forEach((row) => {\n            row.classList.add('hover:bg-gray-200', 'h-20', 'border', 'border-gray-300', 'odd:bg-white', 'even:bg-gray-100', 'transition-colors', 'duration-300', 'ease-in-out');\n            table.appendChild(row);\n        });\n        trackManager.appendTableToDOM(table);\n    }\n    constructor() {\n        this.uiManager = this;\n        this.playlistIdManager = _playlistIdManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistIdManager.getInstance();\n    }\n    // IDに基づいてHTML要素を取得する\n    getElementById(id) {\n        return document.getElementById(id);\n    }\n    // プレイリストフォームを取得する\n    get playlistForm() {\n        return this.getElementById('playlistForm');\n    }\n    // プレイリストトラックDivを取得する\n    get playlistTracksDiv() {\n        return this.getElementById('playlistTracks');\n    }\n    // 検索フォームを取得する\n    get searchForm() {\n        return this.getElementById('searchForm');\n    }\n    // 検索結果Divを取得する\n    get searchResultsDiv() {\n        return this.getElementById('searchResults');\n    }\n    // フォームに送信イベントを追加する\n    addSubmitEventToForm(formId, handler) {\n        const form = this.getElementById(formId);\n        form.addEventListener('submit', handler.bind(this));\n    }\n    // データが有効かどうかを確認する\n    isValidData(data) {\n        return data && Array.isArray(data.tracks);\n    }\n    // プレイリスト名を表示する\n    displayPlaylistName(name) {\n        if (name) {\n            console.log(`Playlist name: ${name}`);\n            const playlistNameElement = document.createElement('h2');\n            playlistNameElement.textContent = `${name}`;\n            playlistNameElement.classList.add('text-4xl', 'font-bold', 'text-green-500', 'mt-4', 'font-sans', 'font-semibold', 'w-full', 'text-center', 'border-b-2', 'border-green-500');\n            this.playlistTracksDiv.insertBefore(playlistNameElement, this.playlistTracksDiv.firstChild);\n        }\n    }\n    // すべてのテーブルをクリアする\n    clearAllTables() {\n        this.playlistTracksDiv.innerHTML = '';\n        this.searchResultsDiv.innerHTML = '';\n    }\n    // テーブルを作成する\n    createDomTable(tracks) {\n        this.clearAllTables();\n        const trackTable = new _trackTable__WEBPACK_IMPORTED_MODULE_4__.TrackTable(tracks);\n        this.playlistTracksDiv.appendChild(trackTable.createTable());\n    }\n    createSearchResultsTable(results) {\n        this.clearAllTables();\n        if (!Array.isArray(results)) {\n            console.error('Expected results to be an array but received', results);\n            return;\n        }\n        const table = this.createTableFromResults(results);\n        this.searchResultsDiv.appendChild(table);\n    }\n    createTableFromResults(results) {\n        const table = document.createElement('table');\n        table.classList.add('min-w-full', 'divide-y', 'divide-gray-200', 'shadow-md', 'rounded-lg', 'overflow-hidden');\n        results.forEach((result) => {\n            const row = this.createDomTableRow(result);\n            table.appendChild(row);\n        });\n        return table;\n    }\n    // 検索結果の各行を作成する\n    createDomTableRow(result) {\n        const row = document.createElement('tr');\n        row.classList.add('odd:bg-white', 'even:bg-gray-100', 'hover:bg-gray-200', 'transition-colors', 'duration-300', 'ease-in-out');\n        const td = this.createTableCell(result.name);\n        const playlistManager = new _playlistManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistManager();\n        this.addClickListener(td, () => playlistManager.fetchAndDisplayPlaylistDetailsUI(result));\n        row.appendChild(td);\n        return row;\n    }\n    createTableCell(text) {\n        const td = document.createElement('td');\n        td.textContent = text;\n        td.classList.add('px-6', 'py-4', 'whitespace-nowrap', 'text-sm', 'font-medium', 'text-gray-900');\n        return td;\n    }\n    addClickListener(element, listener) {\n        element.addEventListener('click', listener);\n    }\n    validateData(data) {\n        if (!data || !Array.isArray(data.tracks)) {\n            throw new Error('Invalid data: Expected data.tracks to be an array');\n        }\n    }\n    displayPlaylistDetails(playlist, data) {\n        this.playlistTracksDiv.innerHTML = '';\n        const trackManager = new _trackManager__WEBPACK_IMPORTED_MODULE_3__.TrackManager();\n        const playlistNameElement = document.createElement('h2');\n        playlistNameElement.textContent = `${playlist.name}`;\n        this.playlistTracksDiv.appendChild(playlistNameElement);\n        if (data && Array.isArray(data.tracks)) {\n            const tracks = data.tracks.map((item) => new _track__WEBPACK_IMPORTED_MODULE_2__.Track(item.playlistTrack.track, item.audioFeatures));\n            this.createDomTable(tracks);\n            trackManager.calculateTrackAverageAndMode(tracks);\n        }\n        else {\n            console.error('Expected data.tracks to be an array but received', data);\n        }\n    }\n    // プレイリストを表示する\n    displayPlaylists(data) {\n        this.playlistTracksDiv.innerHTML = '';\n        if (data && Array.isArray(data)) {\n            this.createSearchResultsTable(data);\n        }\n        else {\n            console.error(`Expected data to be an array but received data of type ${typeof data}`, data);\n        }\n    }\n}\nconst uiManager = new UIManager();\nwindow.addEventListener('resize', uiManager.checkTableWidth);\nuiManager.checkTableWidth();\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/uiManager.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main/typescript/main.ts");
/******/ 	
/******/ })()
;