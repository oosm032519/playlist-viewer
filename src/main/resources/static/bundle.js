/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main/typescript/DescriptionManager.ts":
/*!***************************************************!*\
  !*** ./src/main/typescript/DescriptionManager.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DescriptionManager: () => (/* binding */ DescriptionManager)\n/* harmony export */ });\nclass DescriptionManager {\n    constructor() {\n        this.descriptions = {\n            'Acousticness': 'アコースティック感。1に近いほどアコースティック。',\n            'Danceability': '踊りやすさ。1に近いほど踊りやすい。',\n            'Energy': '曲の激しさ。1に近いほど激しい。',\n            'Liveness': 'ライブ感。1に近いほどライブらしい。',\n            'Speechiness': '曲中の話し言葉の存在度合い。1に近いほど話し言葉が多い。',\n            'Valence': '明るさ。1に近いほど明るい。'\n        };\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/DescriptionManager.ts?");

/***/ }),

/***/ "./src/main/typescript/DomElements.ts":
/*!********************************************!*\
  !*** ./src/main/typescript/DomElements.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DomElements: () => (/* binding */ DomElements)\n/* harmony export */ });\n/* harmony import */ var _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlaylistIdManager */ \"./src/main/typescript/PlaylistIdManager.ts\");\n/* harmony import */ var _TrackTable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TrackTable */ \"./src/main/typescript/TrackTable.ts\");\n/* harmony import */ var _TrackManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrackManager */ \"./src/main/typescript/TrackManager.ts\");\n/* harmony import */ var _Track__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Track */ \"./src/main/typescript/Track.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass DomElements {\n    constructor() {\n        // プレイリストフォームの送信イベントハンドラ\n        this.handlePlaylistFormSubmit = (event) => {\n            event.preventDefault();\n            const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistIdManager.getInstance();\n            playlistIdManager.playlistId = this.playlistIdInput.value;\n            this.fetchPlaylistData(playlistIdManager.playlistId);\n        };\n    }\n    // IDに基づいてHTML要素を取得する\n    getElementById(id) {\n        return document.getElementById(id);\n    }\n    // プレイリストフォームを取得する\n    get playlistForm() {\n        return this.getElementById('playlistForm');\n    }\n    // プレイリストID入力を取得する\n    get playlistIdInput() {\n        return this.getElementById('playlistId');\n    }\n    // プレイリストトラックDivを取得する\n    get playlistTracksDiv() {\n        return this.getElementById('playlistTracks');\n    }\n    // 検索フォームを取得する\n    get searchForm() {\n        return this.getElementById('searchForm');\n    }\n    // 検索クエリ入力を取得する\n    get searchQueryInput() {\n        return this.getElementById('searchQuery');\n    }\n    // 検索結果Divを取得する\n    get searchResultsDiv() {\n        return this.getElementById('searchResults');\n    }\n    // フォームに送信イベントを追加する\n    addSubmitEventToForm(formId, handler) {\n        const form = this.getElementById(formId);\n        form.addEventListener('submit', handler.bind(this));\n    }\n    // APIからデータを取得する\n    fetchDataFromAPI(url, handler) {\n        const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistIdManager.getInstance();\n        playlistIdManager.playlistTrackIds = [];\n        this.clearAllTables();\n        this.showLoadingAnimation();\n        fetch(url)\n            .then(_TrackTable__WEBPACK_IMPORTED_MODULE_1__.TrackTable.handleResponse)\n            .then(handler.bind(this))\n            .catch(_TrackTable__WEBPACK_IMPORTED_MODULE_1__.TrackTable.handleError);\n    }\n    // プレイリストデータを取得する\n    fetchPlaylistData(playlistId) {\n        this.fetchDataFromAPI(`/java/playlist/${playlistId}`, this.handlePlaylistData);\n    }\n    // 検索データを取得する\n    fetchSearchData(searchQuery) {\n        this.fetchDataFromAPI(`/java/search/${searchQuery}`, this.handleSearchData);\n    }\n    // 検索フォームの送信イベントハンドラ\n    handleSearchFormSubmit(event) {\n        event.preventDefault();\n        const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistIdManager.getInstance();\n        playlistIdManager.playlistId = this.searchQueryInput.value;\n        this.fetchSearchData(playlistIdManager.playlistId);\n    }\n    // プレイリストデータの処理\n    handlePlaylistData(data) {\n        this.clearAllTables();\n        this.processPlaylistData(data);\n        this.hideLoadingAnimation();\n    }\n    // 検索データの処理\n    handleSearchData(data) {\n        this.clearAllTables();\n        this.createSearchResultsTable(data);\n        this.hideLoadingAnimation();\n    }\n    // プレイリストデータの処理\n    processPlaylistData(data) {\n        if (this.isValidData(data)) {\n            const tracks = this.createTracks(data);\n            this.createTable(tracks);\n            const trackManager = new _TrackManager__WEBPACK_IMPORTED_MODULE_2__.TrackManager();\n            trackManager.calculateAverageAndMode(tracks);\n            this.displayPlaylistName(data.name);\n        }\n        else {\n            console.error('Expected data.tracks to be an array but received', data);\n        }\n    }\n    // データが有効かどうかを確認する\n    isValidData(data) {\n        return data && Array.isArray(data.tracks);\n    }\n    // トラックを作成する\n    createTracks(data) {\n        return data.tracks.map((item) => {\n            const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistIdManager.getInstance();\n            playlistIdManager.playlistTrackIds.push(item.playlistTrack.track.id);\n            return new _Track__WEBPACK_IMPORTED_MODULE_3__.Track(item.playlistTrack.track, item.audioFeatures);\n        });\n    }\n    // プレイリスト名を表示する\n    displayPlaylistName(name) {\n        if (name) {\n            console.log(`Playlist name: ${name}`);\n            const playlistNameElement = document.createElement('h2');\n            playlistNameElement.textContent = `${name}`;\n            this.playlistTracksDiv.insertBefore(playlistNameElement, this.playlistTracksDiv.firstChild);\n        }\n    }\n    // ローディングアニメーションを表示する\n    showLoadingAnimation() {\n        document.getElementById('loading').classList.remove('hidden');\n    }\n    // ローディングアニメーションを非表示にする\n    hideLoadingAnimation() {\n        document.getElementById('loading').classList.add('hidden');\n    }\n    // すべてのテーブルをクリアする\n    clearAllTables() {\n        this.playlistTracksDiv.innerHTML = '';\n        this.searchResultsDiv.innerHTML = '';\n    }\n    // テーブルを作成する\n    createTable(tracks) {\n        this.clearAllTables();\n        const trackTable = new _TrackTable__WEBPACK_IMPORTED_MODULE_1__.TrackTable(tracks);\n        this.playlistTracksDiv.appendChild(trackTable.createTable());\n    }\n    // 検索結果を表示するテーブルを作成する\n    createSearchResultsTable(results) {\n        this.clearAllTables();\n        if (!Array.isArray(results)) {\n            console.error('Expected results to be an array but received', results);\n            results = [];\n        }\n        const table = document.createElement('table');\n        results.forEach((result) => {\n            const row = this.createTableRow(result);\n            table.appendChild(row);\n        });\n        this.searchResultsDiv.appendChild(table);\n    }\n    // 検索結果の各行を作成する\n    createTableRow(result) {\n        const row = document.createElement('tr');\n        const td = document.createElement('td');\n        td.textContent = result.name;\n        td.addEventListener('click', () => this.fetchAndDisplayPlaylistDetails(result));\n        row.appendChild(td);\n        return row;\n    }\n    // プレイリストの詳細を取得・表示する\n    fetchPlaylistDetails(result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(`/java/playlist/${result.id}`);\n            if (!response.ok) {\n                throw new Error('There was a problem with the fetch operation');\n            }\n            const data = yield response.json();\n            if (!data || !Array.isArray(data.tracks)) {\n                throw new Error('Expected data.tracks to be an array but received ' + data);\n            }\n            return data;\n        });\n    }\n    displayPlaylistDetails(result, data) {\n        this.playlistTracksDiv.innerHTML = '';\n        const playlistNameElement = document.createElement('h2');\n        playlistNameElement.textContent = `${result.name}`;\n        this.playlistTracksDiv.appendChild(playlistNameElement);\n        const tracks = data.tracks.map((item) => new _Track__WEBPACK_IMPORTED_MODULE_3__.Track(item.playlistTrack.track, item.audioFeatures));\n        this.createTable(tracks);\n        const trackManager = new _TrackManager__WEBPACK_IMPORTED_MODULE_2__.TrackManager();\n        trackManager.calculateAverageAndMode(tracks);\n    }\n    fetchAndDisplayPlaylistDetails(result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            document.getElementById('loading').classList.remove('hidden');\n            const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistIdManager.getInstance();\n            playlistIdManager.playlistId = result.id;\n            try {\n                const data = yield this.fetchPlaylistDetails(result);\n                this.displayPlaylistDetails(result, data);\n            }\n            catch (error) {\n                console.error(error.message);\n            }\n            finally {\n                document.getElementById('loading').classList.add('hidden');\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/DomElements.ts?");

/***/ }),

/***/ "./src/main/typescript/FetchManager.ts":
/*!*********************************************!*\
  !*** ./src/main/typescript/FetchManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchManager: () => (/* binding */ FetchManager)\n/* harmony export */ });\n/* harmony import */ var _UIManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIManager */ \"./src/main/typescript/UIManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass FetchManager {\n    // ユーザーが訪れたプレイリストを取得する非同期関数\n    fetchVisitedPlaylists() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // '/java/user/visited-playlists'エンドポイントからデータを取得\n            fetch('/java/user/visited-playlists', { credentials: 'include' })\n                .then(response => response.json()) // レスポンスをJSONに変換\n                .then(data => {\n                // 訪れたプレイリストを表示するためのdiv要素を取得\n                const visitedPlaylistsDiv = document.getElementById('visitedPlaylists');\n                // UIManagerインスタンスを作成\n                const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_0__.UIManager();\n                // テーブルを作成してdiv要素に追加\n                uiManager.createTable(visitedPlaylistsDiv, data);\n            });\n        });\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/FetchManager.ts?");

/***/ }),

/***/ "./src/main/typescript/PlaylistIdManager.ts":
/*!**************************************************!*\
  !*** ./src/main/typescript/PlaylistIdManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlaylistIdManager: () => (/* binding */ PlaylistIdManager)\n/* harmony export */ });\nclass PlaylistIdManager {\n    constructor() {\n        this.playlistTrackIds = [];\n    }\n    static getInstance() {\n        if (!PlaylistIdManager.instance) {\n            PlaylistIdManager.instance = new PlaylistIdManager();\n        }\n        return PlaylistIdManager.instance;\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/PlaylistIdManager.ts?");

/***/ }),

/***/ "./src/main/typescript/PlaylistManager.ts":
/*!************************************************!*\
  !*** ./src/main/typescript/PlaylistManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlaylistManager: () => (/* binding */ PlaylistManager)\n/* harmony export */ });\n/* harmony import */ var _DomElements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DomElements */ \"./src/main/typescript/DomElements.ts\");\n/* harmony import */ var _UIManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIManager */ \"./src/main/typescript/UIManager.ts\");\n/* harmony import */ var _Track__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Track */ \"./src/main/typescript/Track.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass PlaylistManager {\n    // ユーザーのプレイリストを取得する\n    fetchUserPlaylists() {\n        try {\n            const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_1__.UIManager();\n            uiManager.showLoadingAnimation(); // ローディングアニメーションを表示\n            const playlistManager = new PlaylistManager();\n            playlistManager.fetchPlaylistsFromAPI().then(data => {\n                playlistManager.displayPlaylists(data); // プレイリストを表示\n            }).catch(error => {\n                const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_1__.UIManager();\n                uiManager.showMessage(error.message); // エラーメッセージを表示\n            }).finally(() => {\n                const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_1__.UIManager();\n                uiManager.hideLoadingAnimation(); // ローディングアニメーションを非表示にする\n            });\n        }\n        catch (error) {\n            const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_1__.UIManager();\n            uiManager.showMessage(error.message); // エラーメッセージを表示\n        }\n    }\n    // プレイリストを表示する\n    displayPlaylists(data) {\n        const domElements = new _DomElements__WEBPACK_IMPORTED_MODULE_0__.DomElements();\n        domElements.playlistTracksDiv.innerHTML = '';\n        if (Array.isArray(data)) {\n            domElements.createSearchResultsTable(data); // 検索結果のテーブルを作成\n        }\n        else {\n            console.error('Expected data to be an array but received', data);\n        }\n    }\n    // プレイリストの詳細を取得し表示する\n    fetchAndDisplayPlaylistDetails(playlist) {\n        document.getElementById('loading').classList.remove('hidden'); // ローディングアニメーションを表示\n        fetch(`/java/playlist/${playlist.id}`)\n            .then(response => response.json())\n            .then(data => {\n            const domElements = new _DomElements__WEBPACK_IMPORTED_MODULE_0__.DomElements();\n            domElements.playlistTracksDiv.innerHTML = '';\n            const playlistNameElement = document.createElement('h2');\n            playlistNameElement.textContent = `${playlist.name}`;\n            domElements.playlistTracksDiv.appendChild(playlistNameElement); // プレイリスト名を表示\n            if (data && Array.isArray(data.tracks)) {\n                const tracks = data.tracks.map((item) => new _Track__WEBPACK_IMPORTED_MODULE_2__.Track(item.playlistTrack.track, item.audioFeatures));\n                domElements.createTable(tracks); // テーブルを作成\n            }\n            else {\n                console.error('Expected data.tracks to be an array but received', data);\n            }\n            document.getElementById('loading').classList.add('hidden'); // ローディングアニメーションを非表示にする\n        })\n            .catch(error => console.error('There was a problem with the fetch operation: ', error));\n    }\n    // APIからプレイリストを取得する非同期関数\n    fetchPlaylistsFromAPI() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch('/java/spotify/user/playlists');\n            if (!response.ok) {\n                const message = yield response.text();\n                throw new Error(message);\n            }\n            return response.json();\n        });\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/PlaylistManager.ts?");

/***/ }),

/***/ "./src/main/typescript/TableManager.ts":
/*!*********************************************!*\
  !*** ./src/main/typescript/TableManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableManager: () => (/* binding */ TableManager)\n/* harmony export */ });\n/* harmony import */ var _TrackRecommendationManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TrackRecommendationManager */ \"./src/main/typescript/TrackRecommendationManager.ts\");\n/* harmony import */ var _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PlaylistIdManager */ \"./src/main/typescript/PlaylistIdManager.ts\");\n/* harmony import */ var _PlaylistManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PlaylistManager */ \"./src/main/typescript/PlaylistManager.ts\");\n\n\n\nclass TableManager {\n    // テーブルの幅をチェックする関数\n    checkTableWidth() {\n        // 全てのテーブルを取得\n        const tables = document.querySelectorAll('table');\n        tables.forEach((table) => {\n            // テーブルの幅がウィンドウの幅より大きい場合\n            if (table.offsetWidth > window.innerWidth) {\n                // スクロールバーを表示\n                table.style.overflowX = 'scroll';\n            }\n            else {\n                // スクロールバーを非表示\n                table.style.overflowX = 'auto';\n            }\n        });\n    }\n    // visitedPlaylistsDivからテーブルを取得する関数\n    getTable(visitedPlaylistsDiv) {\n        let table = visitedPlaylistsDiv.querySelector('table');\n        if (!table) {\n            table = document.createElement('table');\n            visitedPlaylistsDiv.appendChild(table);\n        }\n        return table;\n    }\n    // テーブルヘッダーを作成する関数\n    createTableHeader() {\n        const thead = document.createElement('thead');\n        const headerRow = document.createElement('tr');\n        const headerCell = document.createElement('th');\n        headerCell.textContent = \"参照履歴\";\n        headerRow.appendChild(headerCell);\n        thead.appendChild(headerRow);\n        return thead;\n    }\n    // テーブルボディを作成する関数\n    createTableBody(table, data) {\n        let tableBody = table.querySelector('tbody');\n        if (!tableBody) {\n            tableBody = document.createElement('tbody');\n            table.appendChild(tableBody);\n        }\n        data.forEach((playlist) => {\n            const row = this.createTableRow(playlist);\n            tableBody.appendChild(row);\n        });\n        return tableBody;\n    }\n    // テーブル行を作成する関数\n    createTableRow(playlist) {\n        const row = document.createElement('tr');\n        const nameCell = document.createElement('td');\n        nameCell.textContent = playlist.name;\n        row.appendChild(nameCell);\n        const playlistManager = new _PlaylistManager__WEBPACK_IMPORTED_MODULE_2__.PlaylistManager();\n        row.addEventListener('click', () => playlistManager.fetchAndDisplayPlaylistDetails(playlist));\n        return row;\n    }\n    // レコメンド曲のデータを処理する関数\n    processRecommendationData(data) {\n        const trackRecommendationManager = new _TrackRecommendationManager__WEBPACK_IMPORTED_MODULE_0__.TrackRecommendationManager();\n        trackRecommendationManager.logResponseData(data);\n        const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistIdManager.getInstance();\n        if (data.tracks) {\n            const filteredTracks = data.tracks.filter((track) => !playlistIdManager.playlistTrackIds.includes(track.id));\n            trackRecommendationManager.logRecommendedTracks(filteredTracks);\n            const tableManager = new TableManager();\n            tableManager.displayRecommendedTracks(filteredTracks);\n        }\n        else {\n            console.log(\"No tracks found in the response.\");\n        }\n    }\n    // 推奨曲を表示する関数\n    displayRecommendedTracks(tracks) {\n        const table = document.createElement('table');\n        table.classList.add('recommendations-table');\n        const trackRecommendationManager = new _TrackRecommendationManager__WEBPACK_IMPORTED_MODULE_0__.TrackRecommendationManager();\n        table.appendChild(trackRecommendationManager.createHeaderRow());\n        const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_1__.PlaylistIdManager.getInstance();\n        const trackPairs = trackRecommendationManager.createTrackPairs(tracks);\n        const rows = trackRecommendationManager.createRowsForTrackPairs(trackPairs, playlistIdManager.playlistId);\n        rows.forEach(row => table.appendChild(row));\n        trackRecommendationManager.appendTableToDOM(table);\n    }\n    // トラックの合計値を計算する関数\n    calculateSum(tracks) {\n        let totalTempo = 0;\n        let totalAcousticness = 0;\n        let totalDanceability = 0;\n        let totalEnergy = 0;\n        let totalLiveness = 0;\n        let totalSpeechiness = 0;\n        let totalValence = 0;\n        let artistNames = [];\n        let keys = [];\n        let modes = [];\n        let playlistTrackIds = [];\n        tracks.forEach(track => {\n            totalTempo += track.audioFeatures.tempo;\n            totalAcousticness += track.audioFeatures.acousticness;\n            totalDanceability += track.audioFeatures.danceability;\n            totalEnergy += track.audioFeatures.energy;\n            totalLiveness += track.audioFeatures.liveness;\n            totalSpeechiness += track.audioFeatures.speechiness;\n            totalValence += track.audioFeatures.valence;\n            artistNames.push(track.artists[0].name);\n            keys.push(track.audioFeatures.key);\n            modes.push(track.audioFeatures.mode);\n            playlistTrackIds.push(track.id);\n        });\n        return {\n            totalTempo,\n            totalAcousticness,\n            totalDanceability,\n            totalEnergy,\n            totalLiveness,\n            totalSpeechiness,\n            totalValence,\n            artistNames,\n            keys,\n            modes,\n            playlistTrackIds\n        };\n    }\n    // 平均値を計算する関数\n    calculateAverage(sum, length) {\n        return {\n            averageTempo: sum.totalTempo / length,\n            averageAcousticness: sum.totalAcousticness / length,\n            averageDanceability: sum.totalDanceability / length,\n            averageEnergy: sum.totalEnergy / length,\n            averageLiveness: sum.totalLiveness / length,\n            averageSpeechiness: sum.totalSpeechiness / length,\n            averageValence: sum.totalValence / length,\n        };\n    }\n    // 最頻値を計算する関数\n    calculateMode(sum) {\n        return {\n            modeKey: this.mode(sum.keys),\n            modeMode: this.mode(sum.modes),\n            topFiveArtistNames: this.getTopFiveMostFrequentValues(sum.artistNames)\n        };\n    }\n    // 配列の最頻値を取得する関数\n    mode(array) {\n        return array.sort((a, b) => array.filter(v => v === a).length\n            - array.filter(v => v === b).length).pop();\n    }\n    // 頻度マップを作成する関数\n    createFrequencyMap(array) {\n        const frequency = {};\n        for (const item of array) {\n            frequency[item] = (frequency[item] || 0) + 1;\n        }\n        return frequency;\n    }\n    // 最頻値を取得する関数\n    getMostFrequentValues(frequency, count) {\n        const sortedKeys = [...Object.keys(frequency)].sort((a, b) => frequency[b] - frequency[a]);\n        return sortedKeys.filter(key => frequency[key] > 1).slice(0, count);\n    }\n    // 配列からランダムな値を取得する関数\n    getRandomValues(array, count) {\n        let values = [];\n        while (values.length < count && array.length > 0) {\n            const randomIndex = Math.floor(Math.random() * array.length);\n            const randomValue = array[randomIndex];\n            if (!values.includes(randomValue)) {\n                values = [...values, randomValue];\n                array.splice(randomIndex, 1);\n            }\n        }\n        return values;\n    }\n    // 最頻値のトップ5を取得する関数\n    getTopFiveMostFrequentValues(array) {\n        const frequency = this.createFrequencyMap(array);\n        const modesCount = 5;\n        let modes = this.getMostFrequentValues(frequency, modesCount);\n        const remainingArtists = Object.keys(frequency).filter(key => frequency[key] === 1);\n        const additionalModesCount = modesCount - modes.length;\n        const additionalModes = this.getRandomValues(remainingArtists, additionalModesCount);\n        return [...modes, ...additionalModes];\n    }\n}\nconst tableManager = new TableManager;\nwindow.addEventListener('resize', tableManager.checkTableWidth);\ntableManager.checkTableWidth();\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/TableManager.ts?");

/***/ }),

/***/ "./src/main/typescript/Track.ts":
/*!**************************************!*\
  !*** ./src/main/typescript/Track.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Track: () => (/* binding */ Track)\n/* harmony export */ });\nclass Track {\n    constructor(track, audioFeatures) {\n        this.id = track.id;\n        this.name = track.name;\n        this.artists = track.artists;\n        this.audioFeatures = audioFeatures;\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/Track.ts?");

/***/ }),

/***/ "./src/main/typescript/TrackManager.ts":
/*!*********************************************!*\
  !*** ./src/main/typescript/TrackManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackManager: () => (/* binding */ TrackManager)\n/* harmony export */ });\n/* harmony import */ var _TableManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TableManager */ \"./src/main/typescript/TableManager.ts\");\n/* harmony import */ var _TrackRecommendationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TrackRecommendationManager */ \"./src/main/typescript/TrackRecommendationManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass TrackManager {\n    // トラックの平均値と最頻値を計算する\n    calculateAverageAndMode(tracks) {\n        const tableManager = new _TableManager__WEBPACK_IMPORTED_MODULE_0__.TableManager();\n        // 合計値を計算する\n        const sum = tableManager.calculateSum(tracks);\n        // 平均値を計算する\n        const average = tableManager.calculateAverage(sum, tracks.length);\n        // 最頻値を計算する\n        const mode = tableManager.calculateMode(sum);\n        // 平均値と最頻値をログに出力する\n        console.log(`Average Tempo: ${average.averageTempo}`);\n        console.log(`Average Acousticness: ${average.averageAcousticness}`);\n        console.log(`Average Danceability: ${average.averageDanceability}`);\n        console.log(`Average Energy: ${average.averageEnergy}`);\n        console.log(`Average Liveness: ${average.averageLiveness}`);\n        console.log(`Average Speechiness: ${average.averageSpeechiness}`);\n        console.log(`Average Valence: ${average.averageValence}`);\n        console.log(`Mode Key: ${mode.modeKey}`);\n        console.log(`Mode Mode: ${mode.modeMode}`);\n        console.log(`Top Five Artist Names: ${mode.topFiveArtistNames}`);\n        console.log(`Playlist Track IDs: ${sum.playlistTrackIds}`);\n        // レコメンドトラックを取得する\n        const trackManager = new TrackManager();\n        trackManager.fetchRecommendedTracks(average.averageTempo, mode.modeKey, average.averageDanceability, average.averageEnergy, average.averageAcousticness, average.averageLiveness, average.averageSpeechiness, average.averageValence, mode.topFiveArtistNames);\n    }\n    // レコメンドトラックを取得する非同期関数\n    fetchRecommendedTracks(averageTempo, averageKey, averageDanceability, averageEnergy, averageAcousticness, averageLiveness, averageSpeechiness, averageValence, topFiveArtistNames) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // アーティスト名をパラメータに変換する\n            const artistNamesParam = topFiveArtistNames.join(',');\n            const trackRecommendationManager = new _TrackRecommendationManager__WEBPACK_IMPORTED_MODULE_1__.TrackRecommendationManager();\n            const tableManager = new _TableManager__WEBPACK_IMPORTED_MODULE_0__.TableManager();\n            // APIからレコメンドトラックを取得する\n            const data = yield trackRecommendationManager.fetchRecommendationsFromAPI(averageTempo, averageKey, averageDanceability, averageEnergy, averageAcousticness, averageLiveness, averageSpeechiness, averageValence, artistNamesParam);\n            // レコメンドトラックのデータを処理する\n            tableManager.processRecommendationData(data);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/TrackManager.ts?");

/***/ }),

/***/ "./src/main/typescript/TrackRecommendationManager.ts":
/*!***********************************************************!*\
  !*** ./src/main/typescript/TrackRecommendationManager.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackRecommendationManager: () => (/* binding */ TrackRecommendationManager)\n/* harmony export */ });\n/* harmony import */ var _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlaylistIdManager */ \"./src/main/typescript/PlaylistIdManager.ts\");\n/* harmony import */ var _DomElements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomElements */ \"./src/main/typescript/DomElements.ts\");\n/* harmony import */ var _UIManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UIManager */ \"./src/main/typescript/UIManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass TrackRecommendationManager {\n    // APIからレコメンドトラックを取得する非同期関数\n    fetchRecommendationsFromAPI(averageTempo, averageKey, averageDanceability, averageEnergy, averageAcousticness, averageLiveness, averageSpeechiness, averageValence, artistNamesParam) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(`/java/recommendations?tempo=${averageTempo}&key=${averageKey}&danceability=${averageDanceability}&energy=${averageEnergy}&acousticness=${averageAcousticness}&liveness=${averageLiveness}&speechiness=${averageSpeechiness}&valence=${averageValence}&modeArtistNames=${artistNamesParam}`);\n            if (!response.ok) {\n                throw new Error('Failed to fetch recommendations');\n            }\n            return yield response.json();\n        });\n    }\n    // レスポンスデータをログに出力する関数\n    logResponseData(data) {\n        console.log(\"Response data:\", data);\n    }\n    // レコメンドトラックをログに出力する関数\n    logRecommendedTracks(tracks) {\n        const playlistIdManager = _PlaylistIdManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistIdManager.getInstance();\n        console.log(\"Recommended tracks based on the playlist:\");\n        tracks.forEach((track) => {\n            console.log(`- ${track.name} by ${track.artists[0].name}`);\n        });\n        console.log(playlistIdManager.playlistTrackIds);\n    }\n    // トラックをペアにする関数\n    createTrackPairs(tracks) {\n        const trackPairs = [];\n        for (let i = 0; i < tracks.length; i += 2) {\n            trackPairs.push(tracks.slice(i, i + 2));\n        }\n        return trackPairs;\n    }\n    // ペアの行を作成する関数\n    createRowForPair(pair, playlistId) {\n        const row = document.createElement('tr');\n        const trackRecommendationManager = new TrackRecommendationManager();\n        pair.forEach((track) => {\n            const cell = trackRecommendationManager.createCellForTrack(track);\n            const addButton = trackRecommendationManager.createAddButton(track, playlistId, cell);\n            const removeButton = trackRecommendationManager.createRemoveButton(track, playlistId, cell, row);\n            row.appendChild(cell);\n            row.appendChild(addButton);\n            row.appendChild(removeButton);\n        });\n        return row;\n    }\n    // トラックのセルを作成する関数\n    createCellForTrack(track) {\n        const cell = document.createElement('td');\n        cell.textContent = `${track.name} by ${track.artists[0].name}`;\n        cell.addEventListener('click', () => {\n            window.open(`https://open.spotify.com/track/${track.id}`, '_blank');\n        });\n        return cell;\n    }\n    // 追加ボタンを作成する関数\n    createAddButton(track, playlistId, cell) {\n        const trackRecommendationManager = new TrackRecommendationManager();\n        return trackRecommendationManager.createTrackButton(track, playlistId, cell, null, true);\n    }\n    // 削除ボタンを作成する関数\n    createRemoveButton(track, playlistId, cell, row) {\n        const trackRecommendationManager = new TrackRecommendationManager();\n        return trackRecommendationManager.createTrackButton(track, playlistId, cell, row, false);\n    }\n    // トラックボタンを作成する関数\n    createTrackButton(track, playlistId, cell, row, isAddButton) {\n        const button = document.createElement('button');\n        button.textContent = isAddButton ? '+' : '-';\n        button.className = 'track-button';\n        const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_2__.UIManager();\n        button.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            if (!playlistId) {\n                console.error('Playlist ID is not set.');\n                return;\n            }\n            const endpoint = isAddButton ? 'addTrack' : 'removeTrack';\n            const successMessage = isAddButton ? '楽曲を追加しました！' : '楽曲を削除しました！';\n            const errorMessage = isAddButton ? '楽曲を追加できませんでした' : '楽曲を削除できませんでした';\n            try {\n                yield this.fetchTrack(`/java/playlist/${endpoint}?trackId=${track.id}&playlistId=${playlistId}`);\n                uiManager.showMessage(successMessage);\n                cell.style.backgroundColor = isAddButton ? 'lightgreen' : (row.sectionRowIndex % 2 === 0 ? '#FFF' : '#F2F2F2');\n            }\n            catch (error) {\n                console.error('There was a problem with the fetch operation: ', error);\n                uiManager.showMessage(errorMessage);\n            }\n        }));\n        return button;\n    }\n    fetchTrack(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url);\n            if (!response.ok) {\n                throw new Error('There was a problem with the fetch operation');\n            }\n        });\n    }\n    // ヘッダー行を作成する関数\n    createHeaderRow() {\n        const headerRow = document.createElement('tr');\n        const headerCell = document.createElement('th');\n        headerCell.textContent = \"Recommended Tracks\";\n        headerRow.appendChild(headerCell);\n        return headerRow;\n    }\n    // トラックペアの行を作成する関数\n    createRowsForTrackPairs(trackPairs, playlistId) {\n        const trackRecommendationManager = new TrackRecommendationManager();\n        return trackPairs.map(pair => trackRecommendationManager.createRowForPair(pair, playlistId));\n    }\n    // テーブルをDOMに追加する関数\n    appendTableToDOM(table) {\n        const domElements = new _DomElements__WEBPACK_IMPORTED_MODULE_1__.DomElements();\n        domElements.playlistTracksDiv.appendChild(table);\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/TrackRecommendationManager.ts?");

/***/ }),

/***/ "./src/main/typescript/TrackTable.ts":
/*!*******************************************!*\
  !*** ./src/main/typescript/TrackTable.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackTable: () => (/* binding */ TrackTable)\n/* harmony export */ });\n/* harmony import */ var _DescriptionManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DescriptionManager */ \"./src/main/typescript/DescriptionManager.ts\");\n\nclass TrackTable {\n    constructor(tracks) {\n        this.tracks = tracks;\n    }\n    static handleResponse(response) {\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n    }\n    static handleError(error) {\n        console.error('There was a problem with the fetch operation: ', error);\n    }\n    createTableHeader() {\n        const thead = document.createElement('thead');\n        const headerRow = document.createElement('tr');\n        ['Track Name', 'Artist Name', 'BPM', 'Key', 'Mode', 'Acousticness', 'Danceability', 'Energy', /* 'Instrumentalness', */ 'Liveness', 'Speechiness', 'Valence'].forEach((text, index) => {\n            const th = this.createHeaderCell(text, index);\n            headerRow.appendChild(th);\n        });\n        thead.appendChild(headerRow);\n        return thead;\n    }\n    createHeaderCell(text, index) {\n        const th = document.createElement('th');\n        th.textContent = text;\n        const descriptions = new _DescriptionManager__WEBPACK_IMPORTED_MODULE_0__.DescriptionManager();\n        if (descriptions.descriptions[text]) {\n            th.title = descriptions.descriptions[text];\n        }\n        th.addEventListener('click', (event) => this.handleHeaderCellClick(event, index));\n        return th;\n    }\n    handleHeaderCellClick(event, index) {\n        const element = event.target;\n        this.toggleSortOrder(element);\n        this.resetSortOrderForOtherColumns(element);\n        this.sortRows(element, index);\n    }\n    toggleSortOrder(element) {\n        if (element.classList.contains('asc')) {\n            element.classList.replace('asc', 'desc');\n        }\n        else if (element.classList.contains('desc')) {\n            element.classList.replace('desc', 'asc');\n        }\n        else {\n            element.classList.add('asc');\n        }\n    }\n    resetSortOrderForOtherColumns(element) {\n        Array.from(element.parentNode.children)\n            .filter(e => e !== element)\n            .forEach(e => e.classList.remove('asc', 'desc'));\n    }\n    sortRows(element, index) {\n        const table = element.closest('table');\n        const tbody = table.querySelector('tbody');\n        const sortOrder = element.classList.contains('asc') ? -1 : 1;\n        const rows = Array.from(tbody.rows);\n        rows.sort((a, b) => TrackTable.sortRows(a, b, index, sortOrder));\n        rows.forEach(row => tbody.appendChild(row));\n    }\n    static sortRows(a, b, columnIndex, sortOrder) {\n        const cellA = TrackTable.getSortValue(a.cells[columnIndex].textContent, columnIndex);\n        const cellB = TrackTable.getSortValue(b.cells[columnIndex].textContent, columnIndex);\n        return (cellA > cellB ? 1 : -1) * sortOrder;\n    }\n    createTableBody() {\n        const tbody = document.createElement('tbody');\n        this.tracks.forEach(track => {\n            const row = this.createRow(track);\n            tbody.appendChild(row);\n        });\n        return tbody;\n    }\n    createRow(track) {\n        const row = document.createElement('tr');\n        [track.name, track.artists[0].name, track.audioFeatures.tempo, this.keyToNote(track.audioFeatures.key), track.audioFeatures.mode, track.audioFeatures.acousticness, track.audioFeatures.danceability, track.audioFeatures.energy, /* track.audioFeatures.instrumentalness, */ track.audioFeatures.liveness, track.audioFeatures.speechiness, track.audioFeatures.valence].forEach(text => {\n            const td = document.createElement('td');\n            td.textContent = text.toString();\n            row.appendChild(td);\n        });\n        return row;\n    }\n    keyToNote(key) {\n        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n        return NOTES[key];\n    }\n    static getSortValue(cell, columnIndex) {\n        const COLUMN_INDEX_NAME_ARTIST = 0;\n        const COLUMN_INDEX_OTHERS = 1;\n        const COLUMN_INDEX_KEY = 3;\n        const COLUMN_INDEX_MODE = 4;\n        if (columnIndex === COLUMN_INDEX_NAME_ARTIST || columnIndex === COLUMN_INDEX_OTHERS || columnIndex === COLUMN_INDEX_KEY || columnIndex === COLUMN_INDEX_MODE) {\n            return cell;\n        }\n        else {\n            return parseFloat(cell);\n        }\n    }\n    createTable() {\n        const table = document.createElement('table');\n        table.classList.add('playlist-table');\n        table.appendChild(this.createTableHeader());\n        table.appendChild(this.createTableBody());\n        return table;\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/TrackTable.ts?");

/***/ }),

/***/ "./src/main/typescript/UIManager.ts":
/*!******************************************!*\
  !*** ./src/main/typescript/UIManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIManager: () => (/* binding */ UIManager)\n/* harmony export */ });\n/* harmony import */ var _TableManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TableManager */ \"./src/main/typescript/TableManager.ts\");\n\nclass UIManager {\n    // メッセージを表示するメソッド\n    showMessage(message) {\n        // UIManagerのインスタンスを作成\n        const uiManager = new UIManager();\n        // メッセージ要素を作成\n        const messageDiv = uiManager.createMessageElement(message);\n        // スタイルを定義\n        const styles = {\n            position: 'fixed',\n            bottom: '20px',\n            right: '20px',\n            padding: '10px',\n            backgroundColor: '#2EBD59',\n            color: 'white',\n            borderRadius: '5px'\n        };\n        // 要素にスタイルを適用\n        uiManager.applyStylesToElement(messageDiv, styles);\n        // メッセージをDOMに追加\n        document.body.appendChild(messageDiv);\n        // 一定時間後にメッセージを削除\n        uiManager.removeElementAfterDelay(messageDiv, 3000);\n    }\n    // ローディングアニメーションを表示するメソッド\n    showLoadingAnimation() {\n        document.getElementById('loading').classList.remove('hidden');\n    }\n    // ローディングアニメーションを非表示にするメソッド\n    hideLoadingAnimation() {\n        document.getElementById('loading').classList.add('hidden');\n    }\n    // テーブルを作成するメソッド\n    createTable(visitedPlaylistsDiv, data) {\n        // TableManagerのインスタンスを作成\n        const tableManager = new _TableManager__WEBPACK_IMPORTED_MODULE_0__.TableManager();\n        // テーブルを取得または作成\n        let table = tableManager.getTable(visitedPlaylistsDiv);\n        // テーブルヘッダーを作成して追加\n        table.appendChild(tableManager.createTableHeader());\n        // テーブルボディを作成して追加\n        table.appendChild(tableManager.createTableBody(table, data));\n        // visitedPlaylistsDivを非表示に設定\n        visitedPlaylistsDiv.classList.add('hidden');\n    }\n    // ダークモードとライトモードを切り替えるメソッド\n    toggleDarkLightMode() {\n        // アイコンを取得\n        const sunIcon = document.getElementById('sun-icon');\n        // アニメーションを設定\n        sunIcon.style.transition = 'transform 0.5s';\n        // クリックイベントを追加\n        sunIcon.addEventListener('click', () => {\n            // ダークモードとライトモードを切り替え\n            document.body.classList.toggle('dark-mode');\n            document.body.classList.toggle('light-mode');\n            // アイコンの回転を設定\n            const rotationDegree = document.body.classList.contains('dark-mode') ? 180 : 0;\n            sunIcon.style.transform = `rotate(${rotationDegree}deg)`;\n        });\n    }\n    // プレイリスト検索オプションを切り替えるメソッド\n    togglePlaylistSearchOption() {\n        // オプションを取得\n        const playlistIdOption = document.getElementById('playlistIdOption');\n        const searchQueryOption = document.getElementById('searchQueryOption');\n        const playlistForm = document.getElementById('playlistForm');\n        const searchForm = document.getElementById('searchForm');\n        // プレイリストIDオプションの変更イベントを追加\n        playlistIdOption.addEventListener('change', () => {\n            if (playlistIdOption.checked) {\n                // プレイリストフォームを表示、検索フォームを非表示に設定\n                playlistForm.classList.remove('hidden');\n                searchForm.classList.add('hidden');\n            }\n        });\n        // 検索クエリオプションの変更イベントを追加\n        searchQueryOption.addEventListener('change', () => {\n            if (searchQueryOption.checked) {\n                // 検索フォームを表示、プレイリストフォームを非表示に設定\n                searchForm.classList.remove('hidden');\n                playlistForm.classList.add('hidden');\n            }\n        });\n    }\n    // サイドメニューを切り替えるメソッド\n    toggleSideMenu() {\n        // ボタンを取得\n        const openButton = document.getElementById('open');\n        const closeButton = document.getElementById('close');\n        const sideMenu = document.querySelector('.side-menu');\n        // オープンボタンのクリックイベントを追加\n        openButton.addEventListener('click', () => {\n            sideMenu.classList.toggle('open');\n        });\n        // クローズボタンのクリックイベントを追加\n        closeButton.addEventListener('click', () => {\n            sideMenu.classList.toggle('open');\n        });\n    }\n    // ログイン結果メッセージを表示するメソッド\n    displayLoginResultMessage() {\n        // URLパラメータを取得\n        const urlParams = new URLSearchParams(window.location.search);\n        const loginResult = urlParams.get('loginResult');\n        if (loginResult) {\n            let message;\n            if (loginResult === 'success') {\n                // ログイン成功メッセージ\n                message = 'Spotifyログインに成功しました';\n            }\n            else if (loginResult === 'failure') {\n                // ログイン失敗メッセージ\n                message = 'Spotifyログインに失敗しました';\n            }\n            if (message) {\n                // メッセージを表示\n                const uiManager = new UIManager();\n                uiManager.showMessage(message);\n            }\n        }\n    }\n    // メッセージ要素を作成するメソッド\n    createMessageElement(message) {\n        const messageDiv = document.createElement('div');\n        messageDiv.textContent = message;\n        return messageDiv;\n    }\n    // 要素にスタイルを適用するメソッド\n    applyStylesToElement(element, styles) {\n        Object.assign(element.style, styles);\n    }\n    // 一定時間後に要素を削除するメソッド\n    removeElementAfterDelay(element, delay) {\n        setTimeout(() => {\n            document.body.removeChild(element);\n        }, delay);\n    }\n}\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/UIManager.ts?");

/***/ }),

/***/ "./src/main/typescript/main.ts":
/*!*************************************!*\
  !*** ./src/main/typescript/main.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _PlaylistManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlaylistManager */ \"./src/main/typescript/PlaylistManager.ts\");\n/* harmony import */ var _DomElements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomElements */ \"./src/main/typescript/DomElements.ts\");\n/* harmony import */ var _UIManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UIManager */ \"./src/main/typescript/UIManager.ts\");\n/* harmony import */ var _FetchManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FetchManager */ \"./src/main/typescript/FetchManager.ts\");\n\n\n\n\ndocument.getElementById('clock-icon').addEventListener('click', function () {\n    const visitedPlaylistsDiv = document.getElementById('visitedPlaylists');\n    visitedPlaylistsDiv.classList.toggle('hidden');\n    const button = this;\n    if (button.textContent === '参照履歴を表示') {\n        button.textContent = '参照履歴を非表示';\n    }\n    else {\n        button.textContent = '参照履歴を表示';\n    }\n});\ndocument.getElementById('spotify-login').addEventListener('click', function () {\n    fetch('/java/authorize')\n        .then(response => response.text())\n        .then(uri => {\n        console.log(\"認証が完了しました\");\n        console.log(uri);\n        window.location.href = uri;\n    })\n        .catch(error => console.error('There was a problem with the fetch operation: ', error));\n});\n// プレイリスト表示ボタンのクリックイベントに関数を紐付ける\nconst playlistManager = new _PlaylistManager__WEBPACK_IMPORTED_MODULE_0__.PlaylistManager();\ndocument.getElementById('show-playlists').addEventListener('click', playlistManager.fetchUserPlaylists);\n// ページ読み込み完了時の処理\ndocument.addEventListener('DOMContentLoaded', () => {\n    const domElements = new _DomElements__WEBPACK_IMPORTED_MODULE_1__.DomElements();\n    domElements.addSubmitEventToForm('playlistForm', domElements.handlePlaylistFormSubmit);\n    domElements.addSubmitEventToForm('searchForm', domElements.handleSearchFormSubmit);\n    const uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_2__.UIManager();\n    const fetchManager = new _FetchManager__WEBPACK_IMPORTED_MODULE_3__.FetchManager();\n    uiManager.toggleDarkLightMode();\n    uiManager.togglePlaylistSearchOption();\n    fetchManager.fetchVisitedPlaylists();\n    uiManager.toggleSideMenu();\n    uiManager.displayLoginResultMessage();\n});\n\n\n//# sourceURL=webpack://playlistinfo/./src/main/typescript/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main/typescript/main.ts");
/******/ 	
/******/ })()
;